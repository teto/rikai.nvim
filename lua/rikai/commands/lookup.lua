-- Get the content of the current line in the buffer
local current_line_content = vim.api.nvim_get_current_line()
-- print(current_line_content)  -- Print the current line content for verification


local provider = require'rikai.providers.sqlite'
local classifier = require'rikai.classifier'
local types = require'rikai.types'
local kanji = require'rikai.kanji'
local expr = require'rikai.expression'
local tokenizer = require'rikai.tokenizers.sudachi'
local logger = require'rikai.log'
local utf8 = require'utf8'
local query = require 'rikai.providers.sqlite'
local api = vim.api

local M = {}

-- pasted
function M.find_window_by_var(name, value)
  for _, win in ipairs(vim.api.nvim_list_wins()) do
    if vim.w[win][name] == value then
      return win
    end
  end
end

-- we should tokenize and based on what we find lookup kanji or not ?
-- でる
-- 
-- How to translate "日高" from our sqlite dbs ?
-- 1. first we tokenize
-- 2. For the first tokenized item
--    a. we detect if it's one kanji (one character) or an expression (several characters)
--    b.
---param args the arguments generated by mega.cmdparse
---@param token string
M.popup_lookup = function(token)
    -- mega.cmdparse generated arguments
    logger.info("%s called", token)
    local word=token

    logger.info("Looking into word: "..word)

    -- find the firest
    -- TODO if length is one, no need to tokenize !
    -- use rikai prefix
    local focus_id = token
    local bufnr = api.nvim_get_current_buf()

    -- here we reimplement part of open_floating_preview
    -- aka we want to check if we've
    local win = M.find_window_by_var(focus_id, bufnr)

    logger.debug("Looking for existing window with focus_id=%s", focus_id)
    -- vim.print("WIN %s", win)
    if win and vim.api.nvim_win_is_valid(win) and vim.fn.pumvisible() == 0 then

        logger.debug("Found a window with focus_id=%s", focus_id)
        -- focus and return the existing buf, win
        api.nvim_set_current_win(win)
        api.nvim_command('stopinsert')
        -- return api.nvim_win_get_buf(win), win
        return win
    else
         logger.debug("Could not find any preexisting popup focus_id=%s", focus_id)   
    end


    if utf8.len(word) > 1 then
        -- todo get first element
        tokens = tokenizer.tokenize(word, true)
        if vim.tbl_isempty(tokens) then
            logger.debug("No tokens found")
            return
        end
        -- returns an array of TokenizationResult
        token = tokens[1][1]
    else
        logger.debug("Word "..word.." is one character: skipping tokenization...")
    end


    -- the chosen token
    local token_code = vim.fn.char2nr(token)
    local token_type = classifier.chartype(token_code)
    local token_len = utf8.len(token)

    local results
    if token_len == 1 and token_type == types.CharacterType.KANJI then
        -- if the token is only a single kanji ask the kanji db
        results = provider.lookup_kanji(token)
    else
        -- we need to pass one character only
        -- lookup expression for vim.fn.char2nr("引く")
        -- vim.fn.nr2char(code)
        results = provider.lookup_expr(token)
    end

    logger.debug("Found "..tostring(#results).. " results")

    assert(results, "There must be a result")
    if vim.tbl_isempty(results) then
        print("No results matching token"..token)
        return
    end

    -- TODO check for kanjis for now but later we can deal with romajis/kanas etc
    -- if it's numeral, ask expression db
    local nr_results = #results
    local formatted_results = {}

    -- TODO limit loop according to max_results
    -- local max_results = 5
    -- TODO use config.ui.separator
    local separator = " ---------- "

    for i, r in ipairs(results) do

        -- add a separator if not first result
        if i > 1 then
            table.insert(formatted_results, separator)
        end

        if token_len == 1 and token_type == types.CharacterType.KANJI then
            -- append radicals
            local radicals = query.lookup_kanji_radicals(token)
            local new_result = kanji.format_kanji(r, radicals)
            for j = 1, #new_result do
                table.insert(formatted_results, new_result[j])
            end
        else
            local new_result = expr.format_expression(token, r)
            for j = 1, #new_result do
                table.insert(formatted_results, new_result[j])
            end
        end
    end

    -- add a link to jisho
    local popupOpts = {
        -- focus existing popup with this id instead of creating one
        focusable = true,
        title = "rikai.nvim",
    }

    if nr_results > 1 then
        popupOpts["title"] = popupOpts["title"] .. " (".. tostring(nr_results) .. " results)"
    end

    local winid = require'rikai.popup'.create_popup(token, formatted_results, popupOpts)
    -- vim.print(vim.w[winid][token])
    return winid
end


return M
