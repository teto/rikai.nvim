--[[
Returns values based on an sqlite db generated by https://github.com/odrevet/edict_database
The db itself is generated via edict
--]]

-- (or sqlite3 = require('lsqlite3complete')) 
local sqlite3 = require('lsqlite3')
local config = require('rikai.config')
local logger = require'rikai.log'

local jmdictdb = config.jmdictdb
local M = {}

function M.kanji_sql(kanji)
    return [[
SELECT character.*, 
GROUP_CONCAT(DISTINCT character_radical.id_radical) as radicals, 
GROUP_CONCAT(DISTINCT on_yomi.reading) AS on_reading, 
GROUP_CONCAT(DISTINCT kun_yomi.reading) AS kun_reading, 
GROUP_CONCAT(DISTINCT meaning.content) AS meanings 
FROM character 
LEFT JOIN character_radical ON character.id = character_radical.id_character
LEFT JOIN on_yomi ON character.id = on_yomi.id_character
LEFT JOIN kun_yomi ON kun_yomi.id_character = character.id 
LEFT JOIN meaning ON meaning.id_character = character.id 
WHERE character.id="]]..kanji..[[";
]]
end


---@param kanji string the kanji to look for
---@return string the SQL query
function M.get_kanji_radicals_query(kanji)
    return [[
    SELECT radical.* 
    FROM radical 
    JOIN character_radical ON character_radical.id_radical = radical.id 
    WHERE character_radical.id_character="]]..kanji..[[";
    ]]
end

-- リョクトウ
-- look at the jmdict DTD  to understand the different value
-- basically if we are dealing with a kanji somewhere in expression, we should match against keb, and reb otherwise ?
-- TODO remove the concat keb_reb_group
function M.query_expr(expr)
    return [[SELECT
  k_ele.id k_ele_id,
  entry.id AS entry_id,
  sense.id AS sense_id,
  (
    SELECT
      GROUP_CONCAT(IFNULL(keb || ':', '') || reb)
    FROM
      r_ele r_ele_sub
      LEFT JOIN r_ele_k_ele ON r_ele_k_ele.id_r_ele = r_ele_sub.id
      LEFT JOIN k_ele k_ele_sub ON r_ele_k_ele.id_k_ele = k_ele_sub.id
    WHERE
      r_ele_sub.id_entry = entry.id
  ) keb_reb_group,
  GROUP_CONCAT(DISTINCT gloss.content) gloss_group,
  GROUP_CONCAT(DISTINCT pos.name) pos_group,
  GROUP_CONCAT(DISTINCT dial.name) dial_group,
  GROUP_CONCAT(DISTINCT misc.name) misc_group,
  GROUP_CONCAT(DISTINCT field.name) field_group
FROM
  entry
  JOIN sense ON sense.id_entry = entry.id
  JOIN gloss ON gloss.id_sense = sense.id
  LEFT JOIN sense_pos ON sense.id = sense_pos.id_sense
  LEFT JOIN pos ON sense_pos.id_pos = pos.id
  LEFT JOIN sense_dial ON sense.id = sense_dial.id_sense
  LEFT JOIN dial ON sense_dial.id_dial = dial.id
  LEFT JOIN sense_misc ON sense.id = sense_misc.id_sense
  LEFT JOIN misc ON sense_misc.id_misc = misc.id
  LEFT JOIN sense_field ON sense.id = sense_field.id_sense
  LEFT JOIN field ON sense_field.id_field = field.id
  JOIN r_ele ON entry.id = r_ele.id_entry
  LEFT JOIN k_ele ON entry.id = k_ele.id_entry
WHERE
  keb = ']]..expr..[['
GROUP BY
  sense.id;
  ]];
end

---@param db_path string 
function M.get_db_handle(db_path)

    -- TODO check if a handle already exists
    local con = config._state[db_path]
    if con then
        logger.debug("Returning existing handle to db: " .. db_path)
        return con
    else
        logger.info("Opening " .. db_path)
        -- open readonly
        local errmsg, _errcode
        con, errmsg, _errcode = sqlite3.open(db_path, sqlite3.OPEN_READONLY)
        if not con then
            vim.notify(string.format("rikai: could not open %s:\n%s", db_path, errmsg))
            return false
        end
        config._state[db_path] = con
    end

    return con
end

--- Lookup translation for a kanji
---@param kanji string Kanji to search for
---@return table
function M.lookup_kanji(kanji)

    local res = {}

    local con = M.get_db_handle(config.kanjidb)
    assert (con, "could not open db")
    local req = M.kanji_sql(kanji)

    logger.info("Looking up kanji: ".. tostring(kanji))
    for a in con:nrows(req) do
        -- res [#res + 1] = a
        table.insert(res, a)
    end

    return res
end


--- Find radicals of the kanji
function M.lookup_kanji_radicals(kanji)

    local res = {}

    local con = M.get_db_handle(config.kanjidb)
    assert (con, "could not open db")
    local req = M.get_kanji_radicals_query(kanji)

    logger.info("Looking up kanji radicals: ".. tostring(kanji))
    for a in con:nrows(req) do
        res [#res + 1] = a
    end

    return res
end

-- lookup several kanjis
-- 押す works for the "simple" db if you need to test
-- function M.lookup_expression(word)
--     print("Opening " .. config.jmdictdb)
--     local con = sqlite3.open(config.jmdictdb)
--     local res = {}
--     -- TODO look wiki for expression
--
-- end


function M.lookup_expr(word)

    -- logger.info("Opening " .. jmdictdb)
    local db = M.get_db_handle(jmdictdb)
    assert(db)
    local res = {}

    local req = M.query_expr(word)

    logger.info("Looking up expr ".. tostring(word))
    for a in db:nrows(req) do
        -- vim.print(a)
        res [#res + 1] = a
    end

    return res
end


return M

