--[[
@mod rikai.providers.sqlite Retrieves radicals, meaning from Edict database

Returns values based on an sqlite db generated by https://github.com/odrevet/edict_database
The db itself is generated via edict
--]]

local sqlite3 = require'lsqlite3'
local config = require'rikai.config'
local logger = require'rikai.log'
local classifier = require'rikai.classifier'
local types = require'rikai.types'
local utf8 = require'utf8'

local M = {}


---@class KanjiResult

---@param kanji string the kanji to look for
---@return string SQL query string
function M.build_kanji_query(kanji)
    return [[
SELECT character.*,
       GROUP_CONCAT(DISTINCT character_radical.id_radical) AS radicals,
       GROUP_CONCAT(DISTINCT on_yomi.reading) AS on_reading,
       GROUP_CONCAT(DISTINCT kun_yomi.reading) AS kun_reading,
       GROUP_CONCAT(DISTINCT meaning.content) AS meanings
  FROM character
       LEFT JOIN
       character_radical ON character.id = character_radical.id_character
       LEFT JOIN
       on_yomi ON character.id = on_yomi.id_character
       LEFT JOIN
       kun_yomi ON kun_yomi.id_character = character.id
       LEFT JOIN
       meaning ON meaning.id_character = character.id
 WHERE character.id = "]]..kanji..[[";
]]

end


---@param kanji string the kanji to look for
---@return string the SQL query
function M.get_radicals_from_kanji_query(kanji)
    return [[
    SELECT radical.* 
    FROM radical 
    JOIN character_radical ON character_radical.id_radical = radical.id 
    WHERE character_radical.id_character="]]..kanji..[[";
    ]]
end

-- lang actually depends on dict
---@param expr string
---@return string SQL query string
function M.query_native_expr(expr)
    local req = [[
SELECT
  entry.id AS entry_id,
  sense.id AS sense_id,
  (
    SELECT
      GROUP_CONCAT(IFNULL(keb || ':', '') || reb)
    FROM
      r_ele r_ele_sub
      LEFT JOIN r_ele_k_ele ON r_ele_k_ele.id_r_ele = r_ele_sub.id
      LEFT JOIN k_ele k_ele_sub ON r_ele_k_ele.id_k_ele = k_ele_sub.id
    WHERE
      r_ele_sub.id_entry = entry.id
  ) keb_reb_group,
  GROUP_CONCAT(DISTINCT gloss.content) gloss_group,
  GROUP_CONCAT(DISTINCT pos.name) pos_group,
  GROUP_CONCAT(DISTINCT dial.name) dial_group,
  GROUP_CONCAT(DISTINCT misc.name) misc_group,
  GROUP_CONCAT(DISTINCT field.name) field_group
FROM
  entry
  JOIN sense ON sense.id_entry = entry.id
  JOIN gloss ON gloss.id_sense = sense.id
  LEFT JOIN sense_pos ON sense.id = sense_pos.id_sense
  LEFT JOIN pos ON sense_pos.id_pos = pos.id
  LEFT JOIN sense_dial ON sense.id = sense_dial.id_sense
  LEFT JOIN dial ON sense_dial.id_dial = dial.id
  LEFT JOIN sense_misc ON sense.id = sense_misc.id_sense
  LEFT JOIN misc ON sense_misc.id_misc = misc.id
  LEFT JOIN sense_field ON sense.id = sense_field.id_sense
  LEFT JOIN field ON sense_field.id_field = field.id
WHERE
  entry.id IN (
    SELECT
      sense.id_entry
    FROM
      sense
      JOIN gloss ON gloss.id_sense = sense.id
    WHERE
      gloss.content = ']]..expr..[['
  )
GROUP BY
  sense.id;
  ]]

  return req
end
-- リョクトウ
-- look at the jmdict DTD  to understand the different value
-- basically if we are dealing with a kanji somewhere in expression, we should match against keb, and reb otherwise ?
-- TODO remove the concat keb_reb_group
---@param expr string
---@return string SQL query string
function M.query_jap_expr(expr)

    local req = [[
SELECT
    entry.id AS entry_id,
    sense.id AS sense_id,
    GROUP_CONCAT(DISTINCT COALESCE(k_ele.keb || ':', '') || r_ele.reb) keb_reb_group,
    GROUP_CONCAT(DISTINCT gloss.content) AS gloss_group,
    GROUP_CONCAT(DISTINCT pos.name) AS pos_group,
    GROUP_CONCAT(DISTINCT dial.name) AS dial_group,
    GROUP_CONCAT(DISTINCT misc.name) AS misc_group,
    GROUP_CONCAT(DISTINCT field.name) AS field_group,
    GROUP_CONCAT(DISTINCT
        CASE
            WHEN sense_xref.reb IS NOT NULL
            THEN COALESCE(sense_xref.keb, '') || ':' || sense_xref.reb
            WHEN sense_xref.keb IS NOT NULL
            THEN sense_xref.keb
        END
    ) AS xref_group,
    GROUP_CONCAT(DISTINCT
        CASE
            WHEN sense_ant.reb IS NOT NULL
            THEN COALESCE(sense_ant.keb, '') || ':' || sense_ant.reb
            WHEN sense_ant.keb IS NOT NULL
            THEN sense_ant.keb
        END
    ) AS ant_group
FROM entry
    JOIN r_ele ON entry.id = r_ele.id_entry
    JOIN sense ON sense.id_entry = entry.id
    JOIN gloss ON gloss.id_sense = sense.id
    LEFT JOIN k_ele ON entry.id = k_ele.id_entry
    LEFT JOIN sense_pos ON sense.id = sense_pos.id_sense
    LEFT JOIN pos ON sense_pos.id_pos = pos.id
    LEFT JOIN sense_dial ON sense.id = sense_dial.id_sense
    LEFT JOIN dial ON sense_dial.id_dial = dial.id
    LEFT JOIN sense_misc ON sense.id = sense_misc.id_sense
    LEFT JOIN misc ON sense_misc.id_misc = misc.id
    LEFT JOIN sense_field ON sense.id = sense_field.id_sense
    LEFT JOIN field ON sense_field.id_field = field.id
    LEFT JOIN sense_xref ON sense.id = sense_xref.id_sense
    LEFT JOIN sense_ant ON sense.id = sense_ant.id_sense
WHERE r_ele.reb = ']]..expr..[['
GROUP BY entry.id, sense.id;
  ]];

  logger.debug(req)
  return req
end

---@param db_path string
---@return any|boolean database connection handle or false on error
function M.get_db_handle(db_path)

    -- TODO check if a handle already exists
    local con = config._state[db_path]
    if con then
        logger.debug("Returning existing handle to db: " .. db_path)
        return con
    else
        logger.info("Opening " .. db_path)
        -- open readonly
        local errmsg, _errcode
        con, errmsg, _errcode = sqlite3.open(db_path, sqlite3.OPEN_READONLY)
        if not con then
            vim.notify(string.format("rikai: could not open %s:\n%s", db_path, errmsg))
            return false
        end
        config._state[db_path] = con
    end

    return con
end

--- Lookup translation for a kanji
---@param kanji string Kanji to search for
---@return KanjiResult
function M.lookup_kanji(kanji)
    local start = vim.uv.now()

    local res = {}

    local con = M.get_db_handle(config.kanjidb)
    assert (con, "could not open db")
    local req = M.build_kanji_query(kanji)

    logger.info("Looking up kanji: ".. tostring(kanji))
    ---@diagnostic disable-next-line: need-check-nil
    for a in con:nrows(req) do
        -- res [#res + 1] = a
        table.insert(res, a)
    end

    vim.uv.update_time()
    local end_time = vim.uv.now()
    logger.info("Kanji search took ".. tostring(end_time-start).. " ms")
    return res
end

---@class KanjiRadicals

--- Find radicals of the kanji
---@param kanji string
---@return table of KanjiRadicals
function M.lookup_kanji_radicals(kanji)

    local res = {}

    local con = M.get_db_handle(config.kanjidb)
    assert (con, "could not open db")
    local req = M.get_radicals_from_kanji_query(kanji)

    logger.info("Looking up kanji radicals: ".. tostring(kanji))
    ---@diagnostic disable-next-line: need-check-nil
    for a in con:nrows(req) do
        res [#res + 1] = a
    end

    return res
end

-- lookup several kanjis
-- 押す works for the "simple" db if you need to test
-- function M.lookup_expression(word)
--     print("Opening " .. config.jmdictdb)
--     local con = sqlite3.open(config.jmdictdb)
--     local res = {}
--     -- TODO look wiki for expression
--
-- end


--- Lookup several kanjis in database
---@param word string
---@return table
function M.lookup_expr(word)

    -- logger.info("Opening " .. jmdictdb)
    local db = M.get_db_handle(config.jmdictdb)
    assert(db)
    local res = {}

    local req = M.query_jap_expr(word)

    logger.info("Looking up expr ".. tostring(word))
    ---@diagnostic disable-next-line: need-check-nil
    for a in db:nrows(req) do
        res [#res + 1] = a
    end

    return res
end

--- Smart lookup: can look for a kanji or an expression
---@param token string
---@return rikai.types.CharacterType
---@return KanjiResult
function M.lookup(token)
    local token_code = vim.fn.char2nr(token)
    local token_type = classifier.chartype(token_code)
    local token_len = utf8.len(token)

    local results
    if token_len == 1 and token_type == types.CharacterType.KANJI then
        -- if the token is only a single kanji ask the kanji db
        results = M.lookup_kanji(token)
        return types.CharacterType.KANJI, results
    else
        -- we need to pass one character only
        -- lookup expression for vim.fn.char2nr("引く")
        -- vim.fn.nr2char(code)
        results = M.lookup_expr(token)
        return types.CharacterType.EXPRESSION, results
    end
end

return M

